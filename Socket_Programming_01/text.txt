
GETADDRINFO(3)           BSD Library Functions Manual           GETADDRINFO(3)

NNAAMMEE
     ggeettaaddddrriinnffoo, ffrreeeeaaddddrriinnffoo -- socket address structure to host and service
     name

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssyyss//ttyyppeess..hh>>
     ##iinncclluuddee <<ssyyss//ssoocckkeett..hh>>
     ##iinncclluuddee <<nneettddbb..hh>>

     _i_n_t
     ggeettaaddddrriinnffoo(_c_o_n_s_t _c_h_a_r _*_h_o_s_t_n_a_m_e, _c_o_n_s_t _c_h_a_r _*_s_e_r_v_n_a_m_e,
         _c_o_n_s_t _s_t_r_u_c_t _a_d_d_r_i_n_f_o _*_h_i_n_t_s, _s_t_r_u_c_t _a_d_d_r_i_n_f_o _*_*_r_e_s);

     _v_o_i_d
     ffrreeeeaaddddrriinnffoo(_s_t_r_u_c_t _a_d_d_r_i_n_f_o _*_a_i);

DDEESSCCRRIIPPTTIIOONN
     The ggeettaaddddrriinnffoo() function is used to get a list of IP addresses and port
     numbers for host _h_o_s_t_n_a_m_e and service _s_e_r_v_n_a_m_e.  It is a replacement for
     and provides more flexibility than the gethostbyname(3) and
     getservbyname(3) functions.

     The _h_o_s_t_n_a_m_e and _s_e_r_v_n_a_m_e arguments are either pointers to NUL-terminated
     strings or the null pointer.  An acceptable value for _h_o_s_t_n_a_m_e is either
     a valid host name or a numeric host address string consisting of a dotted
     decimal IPv4 address or an IPv6 address.  The _s_e_r_v_n_a_m_e is either a deci-
     mal port number or a service name listed in services(5).  At least one of
     _h_o_s_t_n_a_m_e and _s_e_r_v_n_a_m_e must be non-null.

     _h_i_n_t_s is an optional pointer to a struct addrinfo, as defined by
     <_n_e_t_d_b_._h>:

     struct addrinfo {
             int ai_flags;           /* input flags */
             int ai_family;          /* protocol family for socket */
             int ai_socktype;        /* socket type */
             int ai_protocol;        /* protocol for socket */
             socklen_t ai_addrlen;   /* length of socket-address */
             struct sockaddr *ai_addr; /* socket-address for socket */
             char *ai_canonname;     /* canonical name for service location */
             struct addrinfo *ai_next; /* pointer to next in list */
     };

     This structure can be used to provide hints concerning the type of socket
     that the caller supports or wishes to use.  The caller can supply the
     following structure elements in _h_i_n_t_s:

     _a_i___f_a_m_i_l_y      The protocol family that should be used.  When _a_i___f_a_m_i_l_y
                    is set to PF_UNSPEC, it means the caller will accept any
                    protocol family supported by the operating system.

     _a_i___s_o_c_k_t_y_p_e    Denotes the type of socket that is wanted: SOCK_STREAM,
                    SOCK_DGRAM, or SOCK_RAW.  When _a_i___s_o_c_k_t_y_p_e is zero the
                    caller will accept any socket type.

     _a_i___p_r_o_t_o_c_o_l    Indicates which transport protocol is desired, IPPROTO_UDP
                    or IPPROTO_TCP.  If _a_i___p_r_o_t_o_c_o_l is zero the caller will
                    accept any protocol.

     _a_i___f_l_a_g_s       The _a_i___f_l_a_g_s field to which the _h_i_n_t_s parameter points
                    shall be set to zero or be the bitwise-inclusive OR of one
                    or more of the values AI_ADDRCONFIG, AI_ALL, AI_CANONNAME,
                    AI_NUMERICHOST, AI_NUMERICSERV, AI_PASSIVE, AI_V4MAPPED,
                    AI_V4MAPPED_CFG, and AI_DEFAULT.

                    AI_ADDRCONFIG   If the AI_ADDRCONFIG bit is set, IPv4
                                    addresses shall be returned only if an
                                    IPv4 address is configured on the local
                                    system, and IPv6 addresses shall be
                                    returned only if an IPv6 address is con-
                                    figured on the local system.

                    AI_ALL          If the AI_ALL bit is set with the
                                    AI_V4MAPPED bit, then ggeettaaddddrriinnffoo() shall
                                    return all matching IPv6 and IPv4
                                    addresses.  The AI_ALL bit without the
                                    AI_V4MAPPED bit is ignored.

                    AI_CANONNAME    If the AI_CANONNAME bit is set, a success-
                                    ful call to ggeettaaddddrriinnffoo() will return a
                                    NUL-terminated string containing the
                                    canonical name of the specified hostname
                                    in the _a_i___c_a_n_o_n_n_a_m_e element of the first
                                    addrinfo structure returned.

                    AI_NUMERICHOST  If the AI_NUMERICHOST bit is set, it indi-
                                    cates that _h_o_s_t_n_a_m_e should be treated as a
                                    numeric string defining an IPv4 or IPv6
                                    address and no name resolution should be
                                    attempted.

                    AI_NUMERICSERV  If the AI_NUMERICSERV bit is set, then a
                                    non-null _s_e_r_v_n_a_m_e string supplied shall be
                                    a numeric port string.  Otherwise, an
                                    EAI_NONAME error shall be returned.  This
                                    bit shall prevent any type of name resolu-
                                    tion service (for example, NIS+) from
                                    being invoked.

                    AI_PASSIVE      If the AI_PASSIVE bit is set it indicates
                                    that the returned socket address structure
                                    is intended for use in a call to bind(2).
                                    In this case, if the _h_o_s_t_n_a_m_e argument is
                                    the null pointer, then the IP address por-
                                    tion of the socket address structure will
                                    be set to INADDR_ANY for an IPv4 address
                                    or IN6ADDR_ANY_INIT for an IPv6 address.

                                    If the AI_PASSIVE bit is not set, the
                                    returned socket address structure will be
                                    ready for use in a call to connect(2) for
                                    a connection-oriented protocol or
                                    connect(2), sendto(2), or sendmsg(2) if a
                                    connectionless protocol was chosen.  The
                                    IP address portion of the socket address
                                    structure will be set to the loopback
                                    address if _h_o_s_t_n_a_m_e is the null pointer
                                    and AI_PASSIVE is not set.

                    AI_V4MAPPED     If the AI_V4MAPPED flag is specified along
                                    with an _a_i___f_a_m_i_l_y of PF_INET6, then
                                    ggeettaaddddrriinnffoo() shall return IPv4-mapped
                                    IPv6 addresses on finding no matching IPv6
                                    addresses ( _a_i___a_d_d_r_l_e_n shall be 16).  The
                                    AI_V4MAPPED flag shall be ignored unless
                                    _a_i___f_a_m_i_l_y equals PF_INET6.

                    AI_V4MAPPED_CFG
                                    The AI_V4MAPPED_CFG flag behaves exactly
                                    like the AI_V4MAPPED flag if the kernel
                                    supports IPv4-mapped IPv6 addresses. Oth-
                                    erwise it is ignored.

                    AI_DEFAULT      AI_DEFAULT is defined as ( AI_V4MAPPED_CFG
                                    | AI_ADDRCONFIG ).

                    AI_UNUSABLE     To override the automatic AI_DEFAULT
                                    behavior that occurs when _a_i___f_l_a_g_s is zero
                                    pass AI_UNUSABLE instead of zero.  This
                                    suppresses the implicit setting of
                                    AI_V4MAPPED_CFG and AI_ADDRCONFIG, thereby
                                    causing unusable addresses to be included
                                    in the results.

     If _a_i___f_l_a_g_s is zero, ggeettaaddddrriinnffoo() gives the AI_DEFAULT behavior (
     AI_V4MAPPED_CFG | AI_ADDRCONFIG ). To override this default behavior,
     pass any nonzero value for _a_i___f_l_a_g_s, by setting any desired flag values,
     or setting AI_UNUSABLE if no other flags are desired.

     All other elements of the addrinfo structure passed via _h_i_n_t_s must be
     zero or the null pointer.

     If _h_i_n_t_s is the null pointer, ggeettaaddddrriinnffoo() behaves as if the caller pro-
     vided a struct addrinfo with _a_i___f_a_m_i_l_y set to PF_UNSPEC and all other
     elements set to zero or NULL (which includes treating the _a_i___f_l_a_g_s field
     as effectively zero, giving the automatic default AI_DEFAULT behavior).

     After a successful call to ggeettaaddddrriinnffoo(), _*_r_e_s is a pointer to a linked
     list of one or more addrinfo structures.  The list can be traversed by
     following the _a_i___n_e_x_t pointer in each addrinfo structure until a null
     pointer is encountered.  The three members _a_i___f_a_m_i_l_y_, _a_i___s_o_c_k_t_y_p_e_, and
     _a_i___p_r_o_t_o_c_o_l in each returned addrinfo structure are suitable for a call
     to socket(2).  For each addrinfo structure in the list, the _a_i___a_d_d_r mem-
     ber points to a filled-in socket address structure of length _a_i___a_d_d_r_l_e_n.

     This implementation of ggeettaaddddrriinnffoo() allows numeric IPv6 address notation
     with scope identifier, as documented in section 11 of RFC 4007.  By
     appending the percent character and scope identifier to addresses, one
     can fill the sin6_scope_id field for addresses.  This would make manage-
     ment of scoped addresses easier and allows cut-and-paste input of scoped
     addresses.

     At this moment the code supports only link-local addresses with the for-
     mat.  The scope identifier is hardcoded to the name of the hardware
     interface associated with the link (such as ne0).  An example is
     ``fe80::1%ne0'', which means ``fe80::1 on the link associated with the
     ne0 interface''.

     The current implementation assumes a one-to-one relationship between the
     interface and link, which is not necessarily true from the specification.

     All of the information returned by ggeettaaddddrriinnffoo() is dynamically allo-
     cated: the addrinfo structures themselves as well as the socket address
     structures and the canonical host name strings included in the addrinfo
     structures.

     Memory allocated for the dynamically allocated structures created by a
     successful call to ggeettaaddddrriinnffoo() is released by the ffrreeeeaaddddrriinnffoo() func-
     tion.  The _a_i pointer should be an addrinfo structure created by a call
     to ggeettaaddddrriinnffoo().

     The current implementation supports synthesis of NAT64 mapped IPv6
     addresses.  If _h_o_s_t_n_a_m_e is a numeric string defining an IPv4 address (for
     example, ``192.0.2.1'' ) and _a_i___f_a_m_i_l_y is set to PF_UNSPEC or PF_INET6,
     ggeettaaddddrriinnffoo() will synthesize the appropriate IPv6 address(es) (for exam-
     ple, ``64:ff9b::192.0.2.1'' ) if the current interface supports IPv6,
     NAT64 and DNS64 and does not support IPv4. If the AI_ADDRCONFIG flag is
     set, the IPv4 address will be suppressed on those interfaces.  On non-
     qualifying interfaces, ggeettaaddddrriinnffoo() is guaranteed to return immediately
     without attempting any resolution, and will return the IPv4 address if
     _a_i___f_a_m_i_l_y is PF_UNSPEC or PF_INET. NAT64 address synthesis can be dis-
     abled by setting the AI_NUMERICHOST flag. To best support NAT64 networks,
     it is recommended to resolve all IP address literals with _a_i___f_a_m_i_l_y set
     to PF_UNSPEC and _a_i___f_l_a_g_s set to AI_DEFAULT.

     Note that NAT64 address synthesis is always disabled for IPv4 addresses
     in the following ranges: 0.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16,
     192.0.0.0/29, 192.88.99.0/24, 224.0.0.0/4, and 255.255.255.255/32.  Addi-
     tionally, NAT64 address synthesis is disabled when the network uses the
     well-known prefix (64:ff9b::/96) for IPv4 addresses in the following
     ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12, and 192.168.0.0/16.

     Historically, passing a host's own hostname to ggeettaaddddrriinnffoo() has been a
     popular technique for determining that host's IP address(es), but this is
     fragile, and doesn't work reliably in all cases. The appropriate way for
     software to discover the IP address(es) of the host it is running on is
     to use getifaddrs(3).

     The ggeettaaddddrriinnffoo() implementations on all versions of OS X and iOS are
     now, and always have been, thread-safe. Previous versions of this man
     page incorrectly reported that ggeettaaddddrriinnffoo() was not thread-safe.

RREETTUURRNN VVAALLUUEESS
     ggeettaaddddrriinnffoo() returns zero on success or one of the error codes listed in
     gai_strerror(3) if an error occurs.

EEXXAAMMPPLLEESS
     The following code tries to connect to ``www.kame.net'' service ``http''
     via a stream socket.  It loops through all the addresses available,
     regardless of address family.  If the destination resolves to an IPv4
     address, it will use an PF_INET socket.  Similarly, if it resolves to
     IPv6, an PF_INET6 socket is used.  Observe that there is no hardcoded
     reference to a particular address family.  The code works even if
     ggeettaaddddrriinnffoo() returns addresses that are not IPv4/v6.

           struct addrinfo hints, *res, *res0;
           int error;
           int s;
           const char *cause = NULL;

           memset(&hints, 0, sizeof(hints));
           hints.ai_family = PF_UNSPEC;
           hints.ai_socktype = SOCK_STREAM;
           error = getaddrinfo("www.kame.net", "http", &hints, &res0);
           if (error) {
                   errx(1, "%s", gai_strerror(error));
                   /*NOTREACHED*/
           }
           s = -1;
           for (res = res0; res; res = res->ai_next) {
                   s = socket(res->ai_family, res->ai_socktype,
                       res->ai_protocol);
                   if (s < 0) {
                           cause = "socket";
                           continue;
                   }

                   if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
                           cause = "connect";
                           close(s);
                           s = -1;
                           continue;
                   }

                   break;  /* okay we got one */
           }
           if (s < 0) {
                   err(1, "%s", cause);
                   /*NOTREACHED*/
           }
           freeaddrinfo(res0);

     The following example tries to open a wildcard listening socket onto ser-
     vice ``http'', for all the address families available.

           struct addrinfo hints, *res, *res0;
           int error;
           int s[MAXSOCK];
           int nsock;
           const char *cause = NULL;

           memset(&hints, 0, sizeof(hints));
           hints.ai_family = PF_UNSPEC;
           hints.ai_socktype = SOCK_STREAM;
           hints.ai_flags = AI_PASSIVE;
           error = getaddrinfo(NULL, "http", &hints, &res0);
           if (error) {
                   errx(1, "%s", gai_strerror(error));
                   /*NOTREACHED*/
           }
           nsock = 0;
           for (res = res0; res && nsock < MAXSOCK; res = res->ai_next) {
                   s[nsock] = socket(res->ai_family, res->ai_socktype,
                       res->ai_protocol);
                   if (s[nsock] < 0) {
                           cause = "socket";
                           continue;
                   }

                   if (bind(s[nsock], res->ai_addr, res->ai_addrlen) < 0) {
                           cause = "bind";
                           close(s[nsock]);
                           continue;
                   }
                   (void) listen(s[nsock], 5);

                   nsock++;
           }
           if (nsock == 0) {
                   err(1, "%s", cause);
                   /*NOTREACHED*/
           }
           freeaddrinfo(res0);

SSEEEE AALLSSOO
     bind(2), connect(2), send(2), socket(2), gai_strerror(3),
     gethostbyname(3), getnameinfo(3), getservbyname(3), resolver(3),
     hosts(5), resolv.conf(5), services(5), hostname(7), named(8)

     R. Gilligan, S. Thomson, J. Bound, J. McCann, and W. Stevens, _B_a_s_i_c
     _S_o_c_k_e_t _I_n_t_e_r_f_a_c_e _E_x_t_e_n_s_i_o_n_s _f_o_r _I_P_v_6, RFC 3493, February 2003.

     S. Deering, B. Haberman, T. Jinmei, E. Nordmark, and B. Zill, _I_P_v_6 _S_c_o_p_e_d
     _A_d_d_r_e_s_s _A_r_c_h_i_t_e_c_t_u_r_e, RFC 4007, March 2005.

     Craig Metz, "Protocol Independence Using the Sockets API", _P_r_o_c_e_e_d_i_n_g_s _o_f
     _t_h_e _f_r_e_e_n_i_x _t_r_a_c_k_: _2_0_0_0 _U_S_E_N_I_X _a_n_n_u_a_l _t_e_c_h_n_i_c_a_l _c_o_n_f_e_r_e_n_c_e, June 2000.

SSTTAANNDDAARRDDSS
     The ggeettaaddddrriinnffoo() function is defined by the IEEE Std 1003.1-2004
     (``POSIX.1'') specification and documented in RFC 3493, ``Basic Socket
     Interface Extensions for IPv6''.

BSD                              July 1, 2008                              BSD
